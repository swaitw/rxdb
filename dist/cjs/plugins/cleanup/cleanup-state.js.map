{"version":3,"file":"cleanup-state.js","names":["_index","require","_index2","_cleanupHelper","_cleanup","_rxjs","RXSTATE_CLEANUP_QUEUE","PROMISE_RESOLVE_TRUE","startCleanupForRxState","state","rxCollection","collection","rxDatabase","database","cleanupPolicy","Object","assign","DEFAULT_CLEANUP_POLICY","initialCleanupWait","closed","cleanupRxState","runCleanupAfterWrite","isDone","awaitReplicationsInSync","replicationStates","REPLICATION_STATE_BY_COLLECTION","get","Promise","all","map","replicationState","isStopped","awaitInSync","then","requestIdlePromise","firstValueFrom","eventBulks$","catch","promiseWait","runEach"],"sources":["../../../../src/plugins/cleanup/cleanup-state.ts"],"sourcesContent":["import type { RxCleanupPolicy, RxState } from '../../types/index.d.ts';\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils/index.ts';\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication/index.ts';\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper.ts';\nimport { initialCleanupWait } from './cleanup.ts';\nimport { firstValueFrom } from 'rxjs';\n\nlet RXSTATE_CLEANUP_QUEUE: Promise<any> = PROMISE_RESOLVE_TRUE;\n\nexport async function startCleanupForRxState(state: RxState<unknown, unknown>) {\n    const rxCollection = state.collection;\n    const rxDatabase = rxCollection.database;\n    const cleanupPolicy = Object.assign(\n        {},\n        DEFAULT_CLEANUP_POLICY,\n        rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {}\n    );\n\n    await initialCleanupWait(rxCollection, cleanupPolicy);\n    if (rxCollection.closed) {\n        return;\n    }\n\n    // initially cleanup the state\n    await cleanupRxState(state, cleanupPolicy);\n\n    /**\n     * Afterwards we listen to writes\n     * and only re-run the cleanup if there was a write\n     * to the state.\n     */\n    await runCleanupAfterWrite(state, cleanupPolicy);\n}\n/**\n * Runs the cleanup for a single RxState\n */\nexport async function cleanupRxState(\n    state: RxState<unknown, unknown>,\n    cleanupPolicy: RxCleanupPolicy\n) {\n    const rxCollection = state.collection;\n    const rxDatabase = rxCollection.database;\n\n    // run cleanup() until it returns true\n    let isDone = false;\n    while (!isDone && !rxCollection.closed) {\n        if (cleanupPolicy.awaitReplicationsInSync) {\n            const replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\n            if (replicationStates) {\n                await Promise.all(\n                    replicationStates.map(replicationState => {\n                        if (!replicationState.isStopped()) {\n                            return replicationState.awaitInSync();\n                        }\n                    })\n                );\n            }\n        }\n        if (rxCollection.closed) {\n            return;\n        }\n        RXSTATE_CLEANUP_QUEUE = RXSTATE_CLEANUP_QUEUE\n            .then(async () => {\n                if (rxCollection.closed) {\n                    return true;\n                }\n                await rxDatabase.requestIdlePromise();\n                return state._cleanup();\n            });\n        isDone = await RXSTATE_CLEANUP_QUEUE;\n    }\n}\n\nexport async function runCleanupAfterWrite(\n    state: RxState<unknown, unknown>,\n    cleanupPolicy: RxCleanupPolicy\n) {\n    const rxCollection = state.collection;\n    while (!rxCollection.closed) {\n        /**\n         * We only start the timer if there was actually a write\n         * to the collection. Otherwise the cleanup would\n         * just run on intervals even if nothing has changed.\n         */\n        await firstValueFrom(rxCollection.eventBulks$).catch(() => { });\n        await rxCollection.promiseWait(cleanupPolicy.runEach);\n        if (rxCollection.closed) {\n            return;\n        }\n        await cleanupRxState(state, cleanupPolicy);\n    }\n}\n"],"mappings":";;;;;;;;AACA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,cAAA,GAAAF,OAAA;AACA,IAAAG,QAAA,GAAAH,OAAA;AACA,IAAAI,KAAA,GAAAJ,OAAA;AAEA,IAAIK,qBAAmC,GAAGC,2BAAoB;AAEvD,eAAeC,sBAAsBA,CAACC,KAAgC,EAAE;EAC3E,IAAMC,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;EACxC,IAAMC,aAAa,GAAGC,MAAM,CAACC,MAAM,CAC/B,CAAC,CAAC,EACFC,qCAAsB,EACtBL,UAAU,CAACE,aAAa,GAAGF,UAAU,CAACE,aAAa,GAAG,CAAC,CAC3D,CAAC;EAED,MAAM,IAAAI,2BAAkB,EAACR,YAAY,EAAEI,aAAa,CAAC;EACrD,IAAIJ,YAAY,CAACS,MAAM,EAAE;IACrB;EACJ;;EAEA;EACA,MAAMC,cAAc,CAACX,KAAK,EAAEK,aAAa,CAAC;;EAE1C;AACJ;AACA;AACA;AACA;EACI,MAAMO,oBAAoB,CAACZ,KAAK,EAAEK,aAAa,CAAC;AACpD;AACA;AACA;AACA;AACO,eAAeM,cAAcA,CAChCX,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;;EAExC;EACA,IAAIS,MAAM,GAAG,KAAK;EAClB,OAAO,CAACA,MAAM,IAAI,CAACZ,YAAY,CAACS,MAAM,EAAE;IACpC,IAAIL,aAAa,CAACS,uBAAuB,EAAE;MACvC,IAAMC,iBAAiB,GAAGC,uCAA+B,CAACC,GAAG,CAAChB,YAAY,CAAC;MAC3E,IAAIc,iBAAiB,EAAE;QACnB,MAAMG,OAAO,CAACC,GAAG,CACbJ,iBAAiB,CAACK,GAAG,CAACC,gBAAgB,IAAI;UACtC,IAAI,CAACA,gBAAgB,CAACC,SAAS,CAAC,CAAC,EAAE;YAC/B,OAAOD,gBAAgB,CAACE,WAAW,CAAC,CAAC;UACzC;QACJ,CAAC,CACL,CAAC;MACL;IACJ;IACA,IAAItB,YAAY,CAACS,MAAM,EAAE;MACrB;IACJ;IACAb,qBAAqB,GAAGA,qBAAqB,CACxC2B,IAAI,CAAC,YAAY;MACd,IAAIvB,YAAY,CAACS,MAAM,EAAE;QACrB,OAAO,IAAI;MACf;MACA,MAAMP,UAAU,CAACsB,kBAAkB,CAAC,CAAC;MACrC,OAAOzB,KAAK,CAACL,QAAQ,CAAC,CAAC;IAC3B,CAAC,CAAC;IACNkB,MAAM,GAAG,MAAMhB,qBAAqB;EACxC;AACJ;AAEO,eAAee,oBAAoBA,CACtCZ,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,OAAO,CAACD,YAAY,CAACS,MAAM,EAAE;IACzB;AACR;AACA;AACA;AACA;IACQ,MAAM,IAAAgB,oBAAc,EAACzB,YAAY,CAAC0B,WAAW,CAAC,CAACC,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;IAC/D,MAAM3B,YAAY,CAAC4B,WAAW,CAACxB,aAAa,CAACyB,OAAO,CAAC;IACrD,IAAI7B,YAAY,CAACS,MAAM,EAAE;MACrB;IACJ;IACA,MAAMC,cAAc,CAACX,KAAK,EAAEK,aAAa,CAAC;EAC9C;AACJ","ignoreList":[]}