{"version":3,"file":"conflicts.js","names":["_index","require","resolveConflictError","state","input","forkState","conflictHandler","isEqual","realMasterState","newDocumentState","undefined","resolved","resolve","resolvedDoc","Object","assign","_meta","flatClone","_rev","getDefaultRevision","_attachments","lwt","now","createRevision","checkpointKey"],"sources":["../../../src/replication-protocol/conflicts.ts"],"sourcesContent":["import type {\n    RxConflictHandler,\n    RxConflictHandlerInput,\n    RxDocumentData,\n    RxStorageInstanceReplicationState\n} from '../types/index.d.ts';\nimport {\n    getDefaultRevision,\n    createRevision,\n    now,\n    flatClone\n} from '../plugins/utils/index.ts';\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    input: RxConflictHandlerInput<RxDocType>,\n    forkState: RxDocumentData<RxDocType>\n): Promise<RxDocumentData<RxDocType> | undefined> {\n    const conflictHandler: RxConflictHandler<RxDocType> = state.input.conflictHandler;\n\n    const isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, 'replication-resolve-conflict');\n\n    if (isEqual) {\n        /**\n         * Documents are equal,\n         * so this is not a conflict -> do nothing.\n         */\n        return undefined;\n    } else {\n        const resolved = await conflictHandler.resolve(input, 'replication-resolve-conflict');\n        /**\n         * We have a resolved conflict,\n         * use the resolved document data.\n         */\n        const resolvedDoc: RxDocumentData<RxDocType> = Object.assign(\n            {},\n            resolved,\n            {\n                /**\n                 * Because the resolved conflict is written to the fork,\n                 * we have to keep/update the forks _meta data, not the masters.\n                 */\n                _meta: flatClone(forkState._meta),\n                _rev: getDefaultRevision(),\n                _attachments: flatClone(forkState._attachments)\n            }\n        ) as any;\n        resolvedDoc._meta.lwt = now();\n        resolvedDoc._rev = createRevision(\n            await state.checkpointKey,\n            forkState\n        );\n        return resolvedDoc;\n    }\n}\n"],"mappings":";;;;;;AAMA,IAAAA,MAAA,GAAAC,OAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeC,oBAAoBA,CACtCC,KAAmD,EACnDC,KAAwC,EACxCC,SAAoC,EACU;EAC9C,IAAMC,eAA6C,GAAGH,KAAK,CAACC,KAAK,CAACE,eAAe;EAEjF,IAAMC,OAAO,GAAGD,eAAe,CAACC,OAAO,CAACH,KAAK,CAACI,eAAe,EAAEJ,KAAK,CAACK,gBAAgB,EAAE,8BAA8B,CAAC;EAEtH,IAAIF,OAAO,EAAE;IACT;AACR;AACA;AACA;IACQ,OAAOG,SAAS;EACpB,CAAC,MAAM;IACH,IAAMC,QAAQ,GAAG,MAAML,eAAe,CAACM,OAAO,CAACR,KAAK,EAAE,8BAA8B,CAAC;IACrF;AACR;AACA;AACA;IACQ,IAAMS,WAAsC,GAAGC,MAAM,CAACC,MAAM,CACxD,CAAC,CAAC,EACFJ,QAAQ,EACR;MACI;AAChB;AACA;AACA;MACgBK,KAAK,EAAE,IAAAC,gBAAS,EAACZ,SAAS,CAACW,KAAK,CAAC;MACjCE,IAAI,EAAE,IAAAC,yBAAkB,EAAC,CAAC;MAC1BC,YAAY,EAAE,IAAAH,gBAAS,EAACZ,SAAS,CAACe,YAAY;IAClD,CACJ,CAAQ;IACRP,WAAW,CAACG,KAAK,CAACK,GAAG,GAAG,IAAAC,UAAG,EAAC,CAAC;IAC7BT,WAAW,CAACK,IAAI,GAAG,IAAAK,qBAAc,EAC7B,MAAMpB,KAAK,CAACqB,aAAa,EACzBnB,SACJ,CAAC;IACD,OAAOQ,WAAW;EACtB;AACJ","ignoreList":[]}