{"version":3,"file":"rx-collection.js","names":["_rxjs","require","_index","_rxCollectionHelper","_rxQuery","_rxError","_docCache","_queryCache","_changeEventBuffer","_hooks","_rxDocumentPrototypeMerge","_rxStorageHelper","_incrementalWrite","_rxDocument","_overwritable","_defaultConflictHandler","_rxChangeEvent","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","OPEN_COLLECTIONS","exports","Set","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","defaultCacheReplacementPolicy","statics","conflictHandler","defaultConflictHandler","storageInstance","timeouts","incrementalWriteQueue","awaitBeforeReads","_incrementalUpsertQueues","Map","synced","hooks","_subs","createQueryCache","$","checkpoint$","eventBulks$","onClose","closed","onRemove","_applyHookFunctions","asRxCollection","pipe","filter","changeEventBulk","collectionName","add","_proto","prototype","prepare","hasPremiumFlag","count","size","NON_PREMIUM_COLLECTION_LIMIT","promiseWait","newRxError","collection","args","existing","Array","from","values","map","c","db","getWrappedStorageInstance","jsonSchema","IncrementalWriteQueue","primaryPath","newData","oldData","beforeDocumentUpdateWrite","result","_runHooks","mergeMap","rxChangeEventBulkToRxChangeEvents","checkpoint","createChangeEventBuffer","documentConstructor","DocumentCache","bulk","isLocal","events","docData","getRxDocumentConstructor","createNewRxDocument","listenToRemoveSub","internalStore","changeStream","key","version","found","find","event","documentData","context","operation","subscribe","close","Promise","all","fn","push","databaseStorageToken","storageToken","subDocs","eventBulk","id","internal","databaseToken","token","$emit","PROMISE_RESOLVE_VOID","cleanup","_minimumDeletedTime","ensureRxCollectionIsNotClosed","pluginMissing","migrationNeeded","getMigrationState","startMigration","batchSize","migratePromise","insert","json","writeResult","bulkInsert","isError","error","throwIfIsStorageWriteError","insertResult","ensureNotFalsy","success","insertIfNotExists","length","status","conflictDocData","documentInDb","mapDocumentsDataToCacheDocs","docsData","ids","insertRows","hasHooks","useDocData","fillObjectDataBeforeInsert","then","document","index","documents","results","bulkWrite","rxDocuments","ret","getWrittenDocumentsFromBulkWriteResponse","docsMap","forEach","row","doc","set","get","primary","bulkRemove","idsOrDocs","rxDocumentMap","findByIds","exec","d","rxDocument","data","toMutableJSON","removeDocs","writeDoc","flatClone","_deleted","previous","deletedRxDocuments","successIds","getCachedRxDocument","bulkUpsert","insertData","useJsonByDocId","useJson","slice","err","documentId","writeData","getFromMapOrThrow","docDataInDb","getCachedRxDocuments","newDoc","incrementalModify","upsert","bulkResult","incrementalUpsert","queue","_incrementalUpsertEnsureRxDocumentExists","wasInserted","inserted","_incrementalUpsertUpdate","queryObj","runPluginHooks","op","_getDefaultQuery","query","createRxQuery","findOne","selector","limit","mangoQuery","$in","exportJSON","importJSON","_exportedJSON","insertCRDT","_updateObj","addPipeline","_options","addHook","when","fun","parallel","newRxTypeError","includes","boundFun","bind","runName","series","getHooks","instance","tasks","hook","promiseSeries","_runHooksSync","time","res","timeout","setTimeout","delete","PROMISE_RESOLVE_FALSE","clearTimeout","requestIdlePromise","sub","unsubscribe","collections","runAsyncPluginHooks","remove","removeCollectionStorages","storage","multiInstance","password","hashFunction","_createClass2","default","cE","colProto","Object","getPrototypeOf","fnName","ucfirst","_innerDoc","rxCollection","docDataFromCache","getLatestDocumentDataIfExists","resolve","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseInstanceToken","databaseName","devMode","overwritable","isDevMode","createRxCollectionStorageInstance","entries","funName","defineProperty","creator","catch","reject","isRxCollection","obj"],"sources":["../../src/rx-collection.ts"],"sourcesContent":["import {\n    filter,\n    map,\n    mergeMap\n} from 'rxjs';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID,\n    NON_PREMIUM_COLLECTION_LIMIT,\n    hasPremiumFlag\n} from './plugins/utils/index.ts';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance,\n    removeCollectionStorages,\n    ensureRxCollectionIsNotClosed\n} from './rx-collection-helper.ts';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query.ts';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error.ts';\nimport type {\n    RxMigrationState\n} from './plugins/migration-schema/index.ts';\nimport {\n    DocumentCache,\n    mapDocumentsDataToCacheDocs\n} from './doc-cache.ts';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache.ts';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer.ts';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks.ts';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageWriteError,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase,\n    RxConflictHandler,\n    MaybePromise,\n    CRDTEntry,\n    MangoQuerySelectorAndIndex,\n    MigrationStrategies\n} from './types/index.d.ts';\n\nimport {\n    RxSchema\n} from './rx-schema.ts';\n\nimport {\n    createNewRxDocument,\n    getRxDocumentConstructor\n} from './rx-document-prototype-merge.ts';\nimport {\n    getWrappedStorageInstance,\n    getWrittenDocumentsFromBulkWriteResponse,\n    throwIfIsStorageWriteError,\n    WrappedRxStorageInstance\n} from './rx-storage-helper.ts';\nimport { IncrementalWriteQueue } from './incremental-write.ts';\nimport { beforeDocumentUpdateWrite } from './rx-document.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxPipeline, RxPipelineOptions } from './plugins/pipeline/index.ts';\nimport { defaultConflictHandler } from './replication-protocol/default-conflict-handler.ts';\nimport { rxChangeEventBulkToRxChangeEvents } from './rx-change-event.ts';\n\nconst HOOKS_WHEN = ['pre', 'post'] as const;\ntype HookWhenType = typeof HOOKS_WHEN[number];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\ntype HookKeyType = typeof HOOKS_KEYS[number];\nlet hooksApplied = false;\n\nexport const OPEN_COLLECTIONS = new Set<RxCollectionBase<any, any, any>>();\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any; },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any; },\n    Reactivity = any\n> {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: WrappedRxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n    public incrementalWriteQueue: IncrementalWriteQueue<RxDocumentType> = {} as any;\n\n\n    /**\n     * Before reads, all these methods are awaited. Used to \"block\" reads\n     * depending on other processes, like when the RxPipeline is running.\n     */\n    public readonly awaitBeforeReads = new Set<() => MaybePromise<any>>();\n\n    constructor(\n        public readonly database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions, Reactivity>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: MigrationStrategies = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {},\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n\n\n        if (database) { // might be falsy on pseudoInstance\n            this.eventBulks$ = database.eventBulks$.pipe(\n                filter(changeEventBulk => changeEventBulk.collectionName === this.name)\n            );\n        } else { }\n\n\n        /**\n         * Must be last because the hooks might throw on dev-mode\n         * checks and we do not want to have broken collections here.\n         * RxCollection instances created for testings do not have a database\n         * so we do not add these to the list.\n         */\n        if (this.database) {\n            OPEN_COLLECTIONS.add(this);\n        }\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    public _incrementalUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: {\n        [key in HookKeyType]: {\n            [when in HookWhenType]: {\n                series: Function[];\n                parallel: Function[];\n            };\n        }\n    } = {} as any;\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocumentCache<RxDocumentType, OrmMethods> = {} as any;\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public checkpoint$: Observable<any> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer<RxDocumentType> = {} as ChangeEventBuffer<RxDocumentType>;\n\n    /**\n     * Internally only use eventBulks$\n     * Do not use .$ or .observable$ because that has to transform\n     * the events which decreases performance.\n     */\n    public readonly eventBulks$: Observable<RxChangeEventBulk<any>> = {} as any;\n\n\n    /**\n     * When the collection is closed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n    public onClose: (() => MaybePromise<any>)[] = [];\n    public closed = false;\n\n    public onRemove: (() => MaybePromise<any>)[] = [];\n\n    public async prepare(): Promise<void> {\n\n        if (!(await hasPremiumFlag())) {\n\n            /**\n             * When used in a test suite, we often open and close many databases with collections\n             * while not awaiting the database.close() call to improve the test times.\n             * So when reopening collections and the OPEN_COLLECTIONS size is full,\n             * we retry after some times to account for this.\n             */\n            let count = 0;\n            while (count < 10 && OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n                count++;\n                await this.promiseWait(30);\n            }\n            if (OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n                throw newRxError('COL23', {\n                    database: this.database.name,\n                    collection: this.name,\n                    args: {\n                        existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({\n                            db: c.database ? c.database.name : '',\n                            c: c.name\n                        }))\n                    }\n                });\n            }\n        }\n\n\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n        this.incrementalWriteQueue = new IncrementalWriteQueue<RxDocumentType>(\n            this.storageInstance,\n            this.schema.primaryPath,\n            (newData, oldData) => beforeDocumentUpdateWrite(this as any, newData, oldData),\n            result => this._runHooks('post', 'save', result)\n        );\n\n        this.$ = this.eventBulks$.pipe(\n            mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)),\n        );\n        this.checkpoint$ = this.eventBulks$.pipe(\n            map(changeEventBulk => changeEventBulk.checkpoint),\n        );\n\n        this._changeEventBuffer = createChangeEventBuffer<RxDocumentType>(this.asRxCollection);\n        let documentConstructor: any;\n        this._docCache = new DocumentCache(\n            this.schema.primaryPath,\n            this.eventBulks$.pipe(\n                filter(bulk => !bulk.isLocal),\n                map(bulk => bulk.events)\n            ),\n            docData => {\n                if (!documentConstructor) {\n                    documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n                }\n                return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n            }\n        );\n\n\n        const listenToRemoveSub = this.database.internalStore.changeStream().pipe(\n            filter(bulk => {\n                const key = this.name + '-' + this.schema.version;\n                const found = bulk.events.find(event => {\n                    return (\n                        event.documentData.context === 'collection' &&\n                        event.documentData.key === key &&\n                        event.operation === 'DELETE'\n                    );\n                });\n                return !!found;\n            })\n        ).subscribe(async () => {\n            await this.close();\n            await Promise.all(this.onRemove.map(fn => fn()));\n        });\n        this._subs.push(listenToRemoveSub);\n\n\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                isLocal: false,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events,\n                databaseToken: this.database.token,\n                checkpoint: eventBulk.checkpoint,\n                context: eventBulk.context\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    /**\n     * Manually call the cleanup function of the storage.\n     * @link https://rxdb.info/cleanup.html\n     */\n    cleanup(_minimumDeletedTime?: number): Promise<boolean> {\n        ensureRxCollectionIsNotClosed(this);\n        throw pluginMissing('cleanup');\n    }\n\n    // overwritten by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration-schema');\n    }\n    getMigrationState(): RxMigrationState {\n        throw pluginMissing('migration-schema');\n    }\n    startMigration(batchSize: number = 10): Promise<void> {\n        ensureRxCollectionIsNotClosed(this);\n        return this.getMigrationState().startMigration(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getMigrationState().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotClosed(this);\n        const writeResult = await this.bulkInsert([json as any]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, (json as any)[this.schema.primaryPath] as any, json, isError as any);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n        return insertResult;\n    }\n\n    async insertIfNotExists(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const writeResult = await this.bulkInsert([json as any]);\n        if (writeResult.error.length > 0) {\n            const error = writeResult.error[0];\n            if (error.status === 409) {\n                const conflictDocData = error.documentInDb;\n                return mapDocumentsDataToCacheDocs(this._docCache, [conflictDocData])[0];\n\n            } else {\n                throw error;\n            }\n        }\n        return writeResult.success[0];\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotClosed(this);\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n        */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const primaryPath = this.schema.primaryPath;\n\n        const ids = new Set<string>();\n\n        /**\n         * This code is a bit redundant for better performance.\n         * Instead of iterating multiple times,\n         * we directly transform the input to a write-row array.\n         */\n        let insertRows: BulkWriteRow<RxDocumentType>[];\n        if (this.hasHooks('pre', 'insert')) {\n            insertRows = await Promise.all(\n                docsData.map(docData => {\n                    const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n                    return this._runHooks('pre', 'insert', useDocData)\n                        .then(() => {\n                            ids.add((useDocData as any)[primaryPath]);\n                            return { document: useDocData };\n                        });\n                })\n            );\n        } else {\n            insertRows = new Array(docsData.length);\n            const schema = this.schema;\n            for (let index = 0; index < docsData.length; index++) {\n                const docData = docsData[index];\n                const useDocData = fillObjectDataBeforeInsert(schema, docData);\n                ids.add((useDocData as any)[primaryPath]);\n                insertRows[index] = { document: useDocData };\n            }\n        }\n\n\n        if (ids.size !== docsData.length) {\n            throw newRxError('COL22', {\n                collection: this.name,\n                args: {\n                    documents: docsData\n                }\n            });\n        }\n\n        const results = await this.storageInstance.bulkWrite(\n            insertRows,\n            'rx-collection-bulk-insert'\n        );\n\n\n        /**\n         * Often the user does not need to access the RxDocuments of the bulkInsert() call.\n         * So we transform the data to RxDocuments only if needed to use less CPU performance.\n         */\n        let rxDocuments: RxDocument<RxDocumentType, OrmMethods>[];\n        const collection = this;\n        const ret = {\n            get success() {\n                if (!rxDocuments) {\n                    const success = getWrittenDocumentsFromBulkWriteResponse(\n                        collection.schema.primaryPath,\n                        insertRows,\n                        results\n                    );\n                    rxDocuments = mapDocumentsDataToCacheDocs<RxDocumentType, OrmMethods>(collection._docCache, success);\n                }\n                return rxDocuments;\n            },\n            error: results.error\n        };\n\n        if (this.hasHooks('post', 'insert')) {\n            const docsMap: Map<string, RxDocumentType> = new Map();\n            insertRows.forEach(row => {\n                const doc = row.document;\n                docsMap.set((doc as any)[primaryPath] as any, doc);\n            });\n            await Promise.all(\n                ret.success.map(doc => {\n                    return this._runHooks(\n                        'post',\n                        'insert',\n                        docsMap.get(doc.primary),\n                        doc\n                    );\n                })\n            );\n        }\n\n        return ret;\n    }\n\n    async bulkRemove(\n        /**\n         * You can either remove the documents by their ids\n         * or by directly providing the RxDocument instances\n         * if you have them already. This improves performance a bit.\n         */\n        idsOrDocs: string[] | RxDocument<RxDocumentType>[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotClosed(this);\n        const primaryPath = this.schema.primaryPath;\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (idsOrDocs.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        let rxDocumentMap: Map<string, RxDocument<RxDocumentType, OrmMethods>>;\n        if (typeof idsOrDocs[0] === 'string') {\n            rxDocumentMap = await this.findByIds(idsOrDocs as string[]).exec();\n        } else {\n            rxDocumentMap = new Map();\n            (idsOrDocs as RxDocument<RxDocumentType, OrmMethods>[]).forEach(d => rxDocumentMap.set(d.primary, d));\n        }\n\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = rxDocument.toMutableJSON(true) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(\n            removeDocs,\n            'rx-collection-bulk-remove'\n        );\n\n\n        const success = getWrittenDocumentsFromBulkWriteResponse(\n            this.schema.primaryPath,\n            removeDocs,\n            results\n        );\n\n        const deletedRxDocuments: RxDocument<RxDocumentType, OrmMethods>[] = [];\n        const successIds: string[] = success.map(d => {\n            const id = d[primaryPath] as string;\n            const doc = this._docCache.getCachedRxDocument(d);\n            deletedRxDocuments.push(doc);\n            return id;\n        });\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n\n        return {\n            success: deletedRxDocuments,\n            error: results.error\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotClosed(this);\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        const success = insertResult.success.slice(0);\n        const error: RxStorageWriteError<RxDocumentType>[] = [];\n\n        // update the ones that existed already\n        await Promise.all(\n            insertResult.error.map(async (err) => {\n                if (err.status !== 409) {\n                    error.push(err);\n                } else {\n                    const id = err.documentId;\n                    const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                    const docDataInDb = ensureNotFalsy(err.documentInDb);\n                    const doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n                    const newDoc = await doc.incrementalModify(() => writeData);\n                    success.push(newDoc);\n                }\n            })\n        );\n        return {\n            error,\n            success\n        };\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    async upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotClosed(this);\n        const bulkResult = await this.bulkUpsert([json]);\n        throwIfIsStorageWriteError<RxDocumentType>(\n            this.asRxCollection,\n            (json as any)[this.schema.primaryPath],\n            json as any,\n            bulkResult.error[0]\n        );\n        return bulkResult.success[0];\n    }\n\n    /**\n     * upserts to a RxDocument, uses incrementalModify if document already exists\n     */\n    incrementalUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotClosed(this);\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it won't try 2 parallel runs\n        let queue = this._incrementalUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _incrementalUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._incrementalUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[],\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n\n        runPluginHooks('prePrepareRxQuery', {\n            op: 'find',\n            queryObj,\n            collection: this\n        });\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(\n        queryObj?: MangoQueryNoLimit<RxDocumentType> | string\n    ): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods> | null,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n\n        runPluginHooks('prePrepareRxQuery', {\n            op: 'findOne',\n            queryObj,\n            collection: this\n        });\n\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries because it will be overwritten\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            queryObj = flatClone(queryObj);\n            (queryObj as any).limit = 1;\n            query = createRxQuery<RxDocumentType>('findOne', queryObj, this as any);\n        }\n\n\n        return query as any;\n    }\n\n    count(queryObj?: MangoQuerySelectorAndIndex<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        number,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n        const query = createRxQuery('count', queryObj, this as any);\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    findByIds(\n        ids: string[]\n    ): RxQuery<\n        RxDocumentType,\n        Map<string, RxDocument<RxDocumentType, OrmMethods>>,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n        const mangoQuery: MangoQuery<RxDocumentType> = {\n            selector: {\n                [this.schema.primaryPath]: {\n                    $in: ids.slice(0)\n                }\n            } as any\n        };\n        const query = createRxQuery('findByIds', mangoQuery, this as any);\n        return query as any;\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    insertCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]): RxDocument<RxDocumentType, OrmMethods> {\n        throw pluginMissing('crdt');\n    }\n\n\n    addPipeline(_options: RxPipelineOptions<RxDocumentType>): Promise<RxPipeline<RxDocumentType>> {\n        throw pluginMissing('pipeline');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: HookWhenType, key: HookKeyType) {\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n        return this.hooks[key][when];\n    }\n\n    hasHooks(when: HookWhenType, key: HookKeyType) {\n        /**\n         * Performance shortcut\n         * so that we not have to build the empty object.\n         */\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return false;\n        }\n\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return false;\n        }\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\n    }\n\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\n        if (!this.hasHooks(when, key)) {\n            return;\n        }\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is closed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    async close(): Promise<boolean> {\n        if (this.closed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        OPEN_COLLECTIONS.delete(this);\n\n\n        await Promise.all(this.onClose.map(fn => fn()));\n\n        /**\n         * Settings closed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.closed = true;\n\n\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.close();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                /**\n                 * Unsubscribing must be done AFTER the storageInstance.close()\n                 * Because the conflict handling is part of the subscriptions and\n                 * otherwise there might be open conflicts to be resolved which\n                 * will then stuck and never resolve.\n                 */\n                this._subs.forEach(sub => sub.unsubscribe());\n\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postCloseRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    async remove(): Promise<any> {\n        await this.close();\n        await Promise.all(this.onRemove.map(fn => fn()));\n        /**\n         * TODO here we should pass the already existing\n         * storage instances instead of creating new ones.\n         */\n        await removeCollectionStorages(\n            this.database.storage,\n            this.database.internalStore,\n            this.database.token,\n            this.database.name,\n            this.name,\n            this.database.multiInstance,\n            this.database.password,\n            this.database.hashFunction\n        );\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods, any, Reactivity> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _incrementalUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.incrementalModify((_innerDoc) => {\n        return json;\n    });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists<RxDocType>(\n    rxCollection: RxCollection<RxDocType>,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument<RxDocType>;\n        inserted: boolean;\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n    if (docDataFromCache) {\n        return Promise.resolve({\n            doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\n        conflictHandler = defaultConflictHandler\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        password: database.password,\n        devMode: overwritable.isDevMode()\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics,\n            conflictHandler\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                OPEN_COLLECTIONS.delete(collection);\n                return storageInstance.close()\n                    .then(() => Promise.reject(err as Error));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"],"mappings":"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","ignoreList":[]}