{"version":3,"file":"change-event-buffer.js","names":["filter","appendToArray","requestIdlePromiseNoQueue","ChangeEventBuffer","collection","subs","counter","eventCounterMap","WeakMap","buffer","limit","tasks","Set","push","eventBulks$","pipe","bulk","isLocal","subscribe","eventBulk","add","_handleChangeEvents","events","size","then","processTasks","_proto","prototype","Array","from","forEach","task","clear","counterBefore","length","slice","counterBase","index","event","set","getCounter","getBuffer","getArrayIndexByPointer","pointer","oldestEvent","oldestCounter","get","rest","getFrom","ret","currentIndex","nextEvent","runFrom","fn","Error","cE","reduceByLastOfDoc","changeEvents","close","sub","unsubscribe","createChangeEventBuffer"],"sources":["../../src/change-event-buffer.ts"],"sourcesContent":["/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\nimport {\n    Subscription\n} from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport type {\n    RxCollection,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport {\n    appendToArray,\n    requestIdlePromiseNoQueue\n} from './plugins/utils/index.ts';\n\n\n/**\n * This buffer rembemers previous change events\n * so that queries can use them on .exec()\n * to calculate the new result set via event-reduce instead\n * of running the query against the storage.\n */\nexport class ChangeEventBuffer<RxDocType> {\n    /**\n     * These properties are private to ensure they cannot\n     * be read without first processing the lazy tasks.\n     */\n    private subs: Subscription[] = [];\n    private counter: number = 0;\n    private eventCounterMap: WeakMap<\n        RxStorageChangeEvent<RxDocType>,\n        number\n    > = new WeakMap();\n    /**\n     * array with changeEvents\n     * starts with oldest known event, ends with newest\n    */\n    private buffer: RxStorageChangeEvent<RxDocType>[] = [];\n\n    public limit: number = 100;\n\n\n\n    private tasks = new Set<Function>();\n\n    constructor(\n        public collection: RxCollection\n    ) {\n        this.subs.push(\n            this.collection.eventBulks$.pipe(\n                filter(bulk => !bulk.isLocal)\n            ).subscribe(eventBulk => {\n                this.tasks.add(() => this._handleChangeEvents(eventBulk.events));\n                if (this.tasks.size <= 1) {\n                    requestIdlePromiseNoQueue().then(() => {\n                        this.processTasks();\n                    });\n                }\n            })\n        );\n    }\n\n    private processTasks() {\n        if (this.tasks.size === 0) {\n            return;\n        }\n        const tasks = Array.from(this.tasks);\n        tasks.forEach(task => task());\n        this.tasks.clear();\n    }\n\n    private _handleChangeEvents(events: RxStorageChangeEvent<RxDocType>[]) {\n        const counterBefore = this.counter;\n        this.counter = this.counter + events.length;\n        if (events.length > this.limit) {\n            this.buffer = events.slice(events.length * -1);\n        } else {\n            appendToArray(this.buffer, events);\n            this.buffer = this.buffer.slice(this.limit * -1);\n        }\n        const counterBase = counterBefore + 1;\n        const eventCounterMap = this.eventCounterMap;\n        for (let index = 0; index < events.length; index++) {\n            const event = events[index];\n            eventCounterMap.set(event, counterBase + index);\n        }\n    }\n\n    getCounter() {\n        this.processTasks();\n        return this.counter;\n    }\n    getBuffer() {\n        this.processTasks();\n        return this.buffer;\n    }\n\n    /**\n     * gets the array-index for the given pointer\n     * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n     */\n    getArrayIndexByPointer(pointer: number): number | null {\n        this.processTasks();\n        const oldestEvent = this.buffer[0];\n        const oldestCounter = this.eventCounterMap.get(\n            oldestEvent\n        ) as number;\n\n        if (pointer < oldestCounter)\n            return null; // out of bounds\n\n        const rest = pointer - oldestCounter;\n        return rest;\n    }\n\n    /**\n     * get all changeEvents which came in later than the pointer-event\n     * @return array with change-events. If null, pointer out of bounds\n     */\n    getFrom(pointer: number): RxStorageChangeEvent<RxDocType>[] | null {\n        this.processTasks();\n        const ret = [];\n        let currentIndex = this.getArrayIndexByPointer(pointer);\n        if (currentIndex === null) // out of bounds\n            return null;\n\n        while (true) {\n            const nextEvent = this.buffer[currentIndex];\n            currentIndex++;\n            if (!nextEvent) {\n                return ret;\n            } else {\n                ret.push(nextEvent);\n            }\n        }\n    }\n\n    runFrom(pointer: number, fn: Function) {\n        this.processTasks();\n        const ret = this.getFrom(pointer);\n        if (ret === null) {\n            throw new Error('out of bounds');\n        } else {\n            ret.forEach(cE => fn(cE));\n        }\n    }\n\n    /**\n     * no matter how many operations are done on one document,\n     * only the last operation has to be checked to calculate the new state\n     * this function reduces the events to the last ChangeEvent of each doc.\n     * This functionality is currently disabled. It is questionable if\n     * pre-merging the events would really be faster or actually slower.\n     */\n    reduceByLastOfDoc(changeEvents: RxStorageChangeEvent<RxDocType>[]): RxStorageChangeEvent<RxDocType>[] {\n        this.processTasks();\n        return changeEvents.slice(0);\n    }\n\n    close() {\n        this.tasks.clear();\n        this.subs.forEach(sub => sub.unsubscribe());\n    }\n}\n\nexport function createChangeEventBuffer<RxdocType>(\n    collection: RxCollection<RxdocType, any>\n) {\n    return new ChangeEventBuffer<RxdocType>(collection);\n}\n"],"mappings":"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","ignoreList":[]}