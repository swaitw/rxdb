{"version":3,"file":"cleanup-state.js","names":["PROMISE_RESOLVE_TRUE","REPLICATION_STATE_BY_COLLECTION","DEFAULT_CLEANUP_POLICY","initialCleanupWait","firstValueFrom","RXSTATE_CLEANUP_QUEUE","startCleanupForRxState","state","rxCollection","collection","rxDatabase","database","cleanupPolicy","Object","assign","closed","cleanupRxState","runCleanupAfterWrite","isDone","awaitReplicationsInSync","replicationStates","get","Promise","all","map","replicationState","isStopped","awaitInSync","then","requestIdlePromise","_cleanup","eventBulks$","catch","promiseWait","runEach"],"sources":["../../../../src/plugins/cleanup/cleanup-state.ts"],"sourcesContent":["import type { RxCleanupPolicy, RxState } from '../../types/index.d.ts';\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils/index.ts';\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication/index.ts';\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper.ts';\nimport { initialCleanupWait } from './cleanup.ts';\nimport { firstValueFrom } from 'rxjs';\n\nlet RXSTATE_CLEANUP_QUEUE: Promise<any> = PROMISE_RESOLVE_TRUE;\n\nexport async function startCleanupForRxState(state: RxState<unknown, unknown>) {\n    const rxCollection = state.collection;\n    const rxDatabase = rxCollection.database;\n    const cleanupPolicy = Object.assign(\n        {},\n        DEFAULT_CLEANUP_POLICY,\n        rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {}\n    );\n\n    await initialCleanupWait(rxCollection, cleanupPolicy);\n    if (rxCollection.closed) {\n        return;\n    }\n\n    // initially cleanup the state\n    await cleanupRxState(state, cleanupPolicy);\n\n    /**\n     * Afterwards we listen to writes\n     * and only re-run the cleanup if there was a write\n     * to the state.\n     */\n    await runCleanupAfterWrite(state, cleanupPolicy);\n}\n/**\n * Runs the cleanup for a single RxState\n */\nexport async function cleanupRxState(\n    state: RxState<unknown, unknown>,\n    cleanupPolicy: RxCleanupPolicy\n) {\n    const rxCollection = state.collection;\n    const rxDatabase = rxCollection.database;\n\n    // run cleanup() until it returns true\n    let isDone = false;\n    while (!isDone && !rxCollection.closed) {\n        if (cleanupPolicy.awaitReplicationsInSync) {\n            const replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\n            if (replicationStates) {\n                await Promise.all(\n                    replicationStates.map(replicationState => {\n                        if (!replicationState.isStopped()) {\n                            return replicationState.awaitInSync();\n                        }\n                    })\n                );\n            }\n        }\n        if (rxCollection.closed) {\n            return;\n        }\n        RXSTATE_CLEANUP_QUEUE = RXSTATE_CLEANUP_QUEUE\n            .then(async () => {\n                if (rxCollection.closed) {\n                    return true;\n                }\n                await rxDatabase.requestIdlePromise();\n                return state._cleanup();\n            });\n        isDone = await RXSTATE_CLEANUP_QUEUE;\n    }\n}\n\nexport async function runCleanupAfterWrite(\n    state: RxState<unknown, unknown>,\n    cleanupPolicy: RxCleanupPolicy\n) {\n    const rxCollection = state.collection;\n    while (!rxCollection.closed) {\n        /**\n         * We only start the timer if there was actually a write\n         * to the collection. Otherwise the cleanup would\n         * just run on intervals even if nothing has changed.\n         */\n        await firstValueFrom(rxCollection.eventBulks$).catch(() => { });\n        await rxCollection.promiseWait(cleanupPolicy.runEach);\n        if (rxCollection.closed) {\n            return;\n        }\n        await cleanupRxState(state, cleanupPolicy);\n    }\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,8BAA8B;AACnE,SAASC,+BAA+B,QAAQ,yBAAyB;AACzE,SAASC,sBAAsB,QAAQ,qBAAqB;AAC5D,SAASC,kBAAkB,QAAQ,cAAc;AACjD,SAASC,cAAc,QAAQ,MAAM;AAErC,IAAIC,qBAAmC,GAAGL,oBAAoB;AAE9D,OAAO,eAAeM,sBAAsBA,CAACC,KAAgC,EAAE;EAC3E,IAAMC,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;EACxC,IAAMC,aAAa,GAAGC,MAAM,CAACC,MAAM,CAC/B,CAAC,CAAC,EACFZ,sBAAsB,EACtBQ,UAAU,CAACE,aAAa,GAAGF,UAAU,CAACE,aAAa,GAAG,CAAC,CAC3D,CAAC;EAED,MAAMT,kBAAkB,CAACK,YAAY,EAAEI,aAAa,CAAC;EACrD,IAAIJ,YAAY,CAACO,MAAM,EAAE;IACrB;EACJ;;EAEA;EACA,MAAMC,cAAc,CAACT,KAAK,EAAEK,aAAa,CAAC;;EAE1C;AACJ;AACA;AACA;AACA;EACI,MAAMK,oBAAoB,CAACV,KAAK,EAAEK,aAAa,CAAC;AACpD;AACA;AACA;AACA;AACA,OAAO,eAAeI,cAAcA,CAChCT,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;;EAExC;EACA,IAAIO,MAAM,GAAG,KAAK;EAClB,OAAO,CAACA,MAAM,IAAI,CAACV,YAAY,CAACO,MAAM,EAAE;IACpC,IAAIH,aAAa,CAACO,uBAAuB,EAAE;MACvC,IAAMC,iBAAiB,GAAGnB,+BAA+B,CAACoB,GAAG,CAACb,YAAY,CAAC;MAC3E,IAAIY,iBAAiB,EAAE;QACnB,MAAME,OAAO,CAACC,GAAG,CACbH,iBAAiB,CAACI,GAAG,CAACC,gBAAgB,IAAI;UACtC,IAAI,CAACA,gBAAgB,CAACC,SAAS,CAAC,CAAC,EAAE;YAC/B,OAAOD,gBAAgB,CAACE,WAAW,CAAC,CAAC;UACzC;QACJ,CAAC,CACL,CAAC;MACL;IACJ;IACA,IAAInB,YAAY,CAACO,MAAM,EAAE;MACrB;IACJ;IACAV,qBAAqB,GAAGA,qBAAqB,CACxCuB,IAAI,CAAC,YAAY;MACd,IAAIpB,YAAY,CAACO,MAAM,EAAE;QACrB,OAAO,IAAI;MACf;MACA,MAAML,UAAU,CAACmB,kBAAkB,CAAC,CAAC;MACrC,OAAOtB,KAAK,CAACuB,QAAQ,CAAC,CAAC;IAC3B,CAAC,CAAC;IACNZ,MAAM,GAAG,MAAMb,qBAAqB;EACxC;AACJ;AAEA,OAAO,eAAeY,oBAAoBA,CACtCV,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,OAAO,CAACD,YAAY,CAACO,MAAM,EAAE;IACzB;AACR;AACA;AACA;AACA;IACQ,MAAMX,cAAc,CAACI,YAAY,CAACuB,WAAW,CAAC,CAACC,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;IAC/D,MAAMxB,YAAY,CAACyB,WAAW,CAACrB,aAAa,CAACsB,OAAO,CAAC;IACrD,IAAI1B,YAAY,CAACO,MAAM,EAAE;MACrB;IACJ;IACA,MAAMC,cAAc,CAACT,KAAK,EAAEK,aAAa,CAAC;EAC9C;AACJ","ignoreList":[]}